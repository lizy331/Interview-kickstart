# 常见的 Bit Operation

## 1. 与操作（AND）：& (bitwise AND)

int a = 5; // 二进制：0101
int b = 3; // 二进制：0011

a & b = 1: // 0001

**只有两个数的该位都为1时结果才为1，否则为0**

```text
0101
0011
----
0001 = 1
```


**a & b = 1: // 0001**


## 2. 或操作（OR）：| (bitwise OR)


int a = 5; // 二进制：0101
int b = 3; // 二进制：0011
int result = a | b = 7; // 二进制：0111，即结果是7

**将两个数的每一位进行或操作，只要两个数的该位有一个为1结果就为1**

```text
0101
0011
----
0111 = 7
```

**result = a | b = 7**

## 3. 异或操作（XOR）：^ (bitwise XOR)

int a = 5; // 二进制：0101
int b = 3; // 二进制：0011
int result = a ^ b = 6; // 二进制：0110，即结果是6

**当两个数的该位不同时结果为1，相同时结果为0**

```text
0101
0011
----
0110 = 6
```

## 4. 取反操作（NOT）：~ (bitwise NOT)

int a = 5; // 二进制：0101
int result = ~a; // 取反后：1010，即结果是-6（因为Java使用二进制补码表示负数）

将一个数的每一位取反，0变1，1变0

```text
0000 0000 0000 0000 0000 0000 0000 0101
---------------------------------------
1111 1111 1111 1111 1111 1111 1111 1010

首先得到的取反结果是一个负数，因为最左边一位是 1，即负数
java 使用 two's complement 来表示负数
为了 搞清楚
1111 1111 1111 1111 1111 1111 1111 1010
表示的是哪一个 数字
我们需要将这个二进制数字 在此取反然后在 二进制单位中 加 1

  0000 0000 0000 0000 0000 0000 0000 1010
+ 0000 0000 0000 0000 0000 0000 0000 0001
----------------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1011 = 6
  
 但是我们知道这个二进制数字 表示的是 负数
 所以最终结果是 -6
```



## 5. 左移操作（left shift）：<< (left shift)

int a = 5; // 二进制：0101
int result = a << 1; // 左移1位后：1010，即结果是10

将一个数的所有位向左移动指定的位数，右边补0

```text
0101
----
1010 = 10
```

## 6. 右移操作（right shift）：>> (right shift)

int a = 5; // 二进制：0101
int result = a >> 1; // 右移1位后：0010，即结果是2

将一个数的所有位向右移动指定的位数，左边补0

```text
0101
----
0010 = 2
```

## 7. 无符号右移操作（unsigned right shift）：>>> (unsigned right shift)

int a = -5; // 二进制：11111111111111111111111111111011
int result = a >>> 1; // 无符号右移1位后：01111111111111111111111111111101，即结果是2147483645


```text

```